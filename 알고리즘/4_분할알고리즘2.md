# 4강. 분할정복 알고리즘(2)

# 합병 정렬

- 전형적인 분할정복 방법이 적용된 알고리즘
    - 분할: 입력 크기 n인 배열을 크기 n/2인 두 부분배열로 분할한다.(더 이상 자를 수 없을 때까지)
    - 정복: 각각의 부분배열에 대해서 합병 정렬을 순환적으로 적용하여 두 부분 배열을 정렬한다.
    - 결합: 정렬된 두 부분배열을 합병하여 하나의 정렬된 배열을 만든다.
    
    ```java
    MergeSort(A[], n){
    if(n>1){
      Mid = n/2;
      B[0..Mid-1] = MergeSort(A[0..Mid-1], Mid); // 왼쪽 부분 배열
      C[0..n-Mid-1] = MergeSort(A[0..n-Mid-1], n-Mid); // 오른쪽 부분 배열
      // 합병 과정(A[] <- B[] + C[])
      A[0..n-1] = Merge(B[0..Mid-1], C[0..n-Mid-1], Mid, n-Mid);
    }
    return A;
    }
    ```
    
- 합병 함수 Merge() 수행시간
    - 두 부분배열 간의 비교 횟수
    - 최악의 경우 : O(n) ⇒ 데이터 개수 만큼 비교했을 경우
    - 입력 데이터 개수 n만큼의 추가 저장 장소가 필요하다. ⇒ 제자리 정렬 알고리즘이 아니다라고 칭한다고 한다.
- 합병 함수 MergeSort() 수행시간
    - O(nlogn)

---

# 선택 문제

- n개의 원소가 임의의 순서로 저장된 배열 A[0..n-1]에서 i번째로 작은 원소를 찾는 문제.

### 알고리즘1 ⇒ 최악 O(n^2), 평균 O(n) 알고리즘

### 알고리즘2 ⇒ 최악 O(n), 평균 O(n) 알고리즘

## 최솟값 찾기

- 각 데이터를 하나씩 모두 비교하는 방법
    - n개의 데이터에 대해서 적어도 n-1 번의 비교가 필요 ⇒ O(n)

```java
FindMinimum(A[], n){
  min = A[0];
  for(i=1; i<n;i++){
    if (A[i]<min) min=A[i]
  return min;
}
```

## 최솟값과 최댓값 모두 찾기

### 방법 1 : 최솟값을 찾은 후 최댓값 찾기 혹은 반대로

- n개의 데이터에서 최솟값을 찾는데 n-1번 비교 + n-1개의 데이터에서 최댓값을 찾는데 n-2번 비교 = 2n-3번의 비교 = O(n)

### 방법 2(개선된 방법): 모든 원소를 두 개씩 짝을 이루어 동시에 최솟값/최댓값과 비교

- 3/2(n-2) 번의 비교

## i번째로 작은 원소 찾기

### 첫번 째 방법

- 퀵 정렬의 분할 함수 Partition()을 순환적으로 적용하는 방법
- 성능 분석
    - 최악의 경우 = 퀵 정렬의 최악의 경우
        - 분할 함수 Partition()이 항상 하나의 부분 배열만 생성하는 경우.
    - 해결 방법: 항상 일정한 비율의 두 부분배열로 분할 → 최악의 경우에도 O(n).

### 두번째 방법

- 항상 일정한 비율의 두 부분배열로 분할되도록 특정 성질을 만족하는 값을 피벗으로 선택.
- 피벗 선택 방법
    - 크기 n인 배열의 원소를 5개씩 묶어서 n/5개의 그룹을 만듬.
        - 5의 배수가 되지 않아 그룹을 형성하지 못한 채 남은 원소는 그대로 남겨둔다.(버린다)
    - 각 그룹에 대해서 중간값을 찾음
    - n/5개의 중간값을 대상으로 다시 중간값을 찾음.
        - 중간값들의 중간값 → 피벗.
