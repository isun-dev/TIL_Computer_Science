# 패키지

## 패키지의 의미

- 관련이 있는 클래스와 인터페이스의 묶음
    - 클래스와 인터페이스는 패키지의 멤버로 존재
- 전체적으로 계층 구조의 클래스 라이브러리
    - 패키지(폴더와 유사) 단위로 계층적으로 분류됨
- 패키지의 용도
    - 쉽게 찾아 사용하기 위해
    - 이름 충돌을 피하기 위해
    - 접근 제어를 위해

## 시스템 패키지

- JDK가 제공하는 클래스 라이브러리
    - JDK와 함께 설치됨
    - 클래스 파일들은 기능에 따라 패키지로 묶여 분류됨
    - 일반적으로 jar 파일로 압축되어 있음

### 시스템 패키지 사용

- 가장 기본이 되는 최상위 시스템 패키지는 java임
    - 대부분 시스템 패키지는 java.으로 시작됨
- Java 프로그램에서 상위 패키지와 하위 패키지의 구분을 위해 . 을 사용
- Java 언어에서 가장 기본적인 클래스는 java.lang 패키지에 존재

## 사용자 정의 패키지

- package 패키지 이름; // 1개 이상의 클래스나 인터페이스 정의가 나옴
    - package 구문은 소스 코드 맨 앞에 위치해야 함
    - 패키지 이름은 관례상 모두 소문자로 작명
    - 도트(.)로 구분하여 계층적으로 정의할 수 있음
    - 컴파일하면 패키지가 만들어지고 (또는 기존 패키지에) 클래스 파일(.class)이 패키지에 저장됨.
- 패키지 정의 예

```java
package com.vehicle;
public class Car {
	String szType = "승용차";
}
```

- 컴파일 결과로 Car.class가 만들어짐
- Car.class는 com.vehicle 패키지에 저장됨

## 패키지와 클래스의 사용

- 다른 패키지에 존재하는 public 클래스를 사용하려면 기본적으로 패키지 경로를 포함한 완전한 클래스 이름을 사용해야 한다.
    - 프로그램에서 자주 사용한다면 import 구문을 사용하는 게 좋음.

# 예외와 에러

- 에러(Error)는 심각한 오류로 더 이상의 실행이 불가함
- 예외(Exception)는 경미한 오류로 복구가 가능함
    - 예외는 정상적 실행 흐름을 방해하는 예외적 사건
- 예외 발생과 처리
    - 메소드를 수행할 때 예외가 발생하면 예외 객체를 만들어 던짐
    - 예외처리 코드가 없으면, 오류 메시지가 출력되면서 프로그램이 즉시 종료된다.
    - 예외처리 코드가 있으면, 예외 객체를 잡아 처리한 뒤, 프로그램은 계속 수행됨
    - 예외 객체는 Exception 클래스 (또는 하위 클래스)로 표현되며 예외 발생 정보를 가지고 있음.
    - ![스크린샷 2022-05-22 오후 5 44 08](https://user-images.githubusercontent.com/43905552/169686438-91f04f66-5403-49b4-8e4c-2c43f19a40fa.png)
    - Checked Exception은 반드시 예외처리를 하도록 강제되어 있다. 

## 예외 처리

- 예외가 발생했을 때 이 상황을 바로잡아 계속 수행하도록 하는 것
- 예외 발생 시, Exception 객체를 생성하고 throw 함
    - throw new MyException();
- throw된 예외 객체를 예외 처리 코드가 catch하여 예외를 처리함
- 예외의 종류
    - checked Exception이 발생할 수 있는 경우, 반드시 명시적인 예외처리가 필요함(예외 처리 코드가 없으면 컴파일 오류가 난다)
- RuntimeException의 경우, 예외처리를 안해도 됨
    - 프로그램을 정확하게 작성하지 않은 경우 발생됨
        - ArithmeticException, NullpointerException 등

## 예외 처리 방법

### 직접 처리

- 예외가 발생한 곳에서 예외 객체를 잡아서 처리하는 것
- try-catch 구문 또는 try-catch-finally 구문을 사용하여 예외를 처리함
- 일반 코드와 예외 처리가 분리되어 가독성이 좋아짐

### 간접 처리(예외의 전파)

- 예외 발생 가능성이 있는 메소드의 선언에서 괄호 다음에 throws 예외이름을 사용
- 그 메소드를 호출한 메소드에게 예외처리를 전달 또는 위임

### try-catch-finally 구문

- 문법

```java
try { ... }
catch(ExceptionType1 ex1) { ... }
finally {}
```

- 예외 객체를 throw하는 문장 또는 예외 발생 가능성이 있는 메소드의 호출 부분을 try 블록에 둠
- catch 블록은 1개의 예외 유형 인자를 가지는 메소드와 유사
    - 처리해야 하는 예외 유형이 여럿이면 catch 블록도 여럿이 됨
- finally 블록은 생략 가능

### try-catch-finally 구문의 실행

- 예외가 발생하면 try 블록은 즉시 종료 됨
- catch 블록이 여럿이면, 가장 적합한 (발생된 예외 자료형과 일치하거나 상위 유형) 하나만 실행된다.
- 예외가 발생하지 않으면 catch 블록은 실행되지 않음
- finally 블록은 예외 발생과 무관하게 try 블록이 종료된 후 항상 실행된다.
    - 할당 받아 사용했던 리소스를 원상복구 하기 위해 finally 블록을 주로 사용함
    - 예) try 블록에서 open 했던 파일을 close 하는 코드를 finally 블록에 둠.

### 예외의 간접 처리

- 예외를 발생시킬 수 있는 메소드를 호출하는 쪽에 예외처리를 위임하는 것(예외의 전파)
    - 메소드 선언에서 발생 시킬수 있는 예외 유형을 표시함
    - 즉 메소드 선언에서 괄호 다음에 throws 예외 유형을 사용
    
    ```java
    public char getInput() throws IOException {
      nInput = System.in.read(); // 예외 발생 가능
    ```
    
    - 메소드 선언에서 throws 절이 표시된 메소드를 호출하는 메소드는 예외 처리를 해야 한다.
    
    ```java
    try {
        c = obj.getInput();
    }catch(Exception e){}
    ```
